%{
Generate a feature matrix G for vectors using simulated QED data
%}

%% Load data
%clear;
%load("QED_simulation_data.mat");

%% Integrate library
addpath("../SPIDER_functions/");

number_of_library_terms = 5;  %under-estimate this
number_of_windows       = 128;%number of domains we integrate over 
degrees_of_freedom      = 2;  %scalars have one degree of freedom
dimension               = 3;  %how many dimensions does our data have?
envelope_power          = 4;  %weight is (1-x^2)^power
size_vec                = [ 32, 32, 32 ]; %how many gridpoints should we use per integration?
buffer                  = 3; %Don't use points this close to boundary

%define shorthand notation
nl = number_of_library_terms;
nw = number_of_windows;
dof= degrees_of_freedom;

%Make important objects for integration
pol      = envelope_pol( envelope_power, dimension );
G        = zeros( dof*nw, nl );
labels   = cell(nl, 1);
scales   = zeros(1,nl);

size_of_data = size(As, 1:dimension);
corners = pick_subdomains( size_of_data, size_vec, buffer, nw );

%Compute secondary fields we might want (charge density and current)

rho = sum( abs(Qs).^2 - abs(Ps).^2, 4 );

J = 0*Es; %J will be current density
J(:,:,:,1) = conj( Qs(:,:,:,1) ).*Qs(:,:,:,4) + ...
             conj( Qs(:,:,:,2) ).*Qs(:,:,:,3) + ...
             conj( Qs(:,:,:,3) ).*Qs(:,:,:,2) + ...
             conj( Qs(:,:,:,4) ).*Qs(:,:,:,1) - ...
             conj( Ps(:,:,:,1) ).*Ps(:,:,:,4) - ...
             conj( Ps(:,:,:,2) ).*Ps(:,:,:,3) - ...
             conj( Ps(:,:,:,3) ).*Ps(:,:,:,2) - ...
             conj( Ps(:,:,:,4) ).*Ps(:,:,:,1);
 
J(:,:,:,2) = -1i*conj( Qs(:,:,:,1) ).*Qs(:,:,:,4) + ...
              1i*conj( Qs(:,:,:,2) ).*Qs(:,:,:,3) + ...
             -1i*conj( Qs(:,:,:,3) ).*Qs(:,:,:,2) + ...
              1i*conj( Qs(:,:,:,4) ).*Qs(:,:,:,1) - ...
             -1i*conj( Ps(:,:,:,1) ).*Ps(:,:,:,4) - ...
              1i*conj( Ps(:,:,:,2) ).*Ps(:,:,:,3) - ...
             -1i*conj( Ps(:,:,:,3) ).*Ps(:,:,:,2) - ...
              1i*conj( Ps(:,:,:,4) ).*Ps(:,:,:,1);
J = real(J);

%Define characteristic scales
mean_E  = mean( abs(Es), 'all' );
mean_A  = mean( abs(As), 'all' );
mean_rho= mean(abs(rho), 'all' );
mean_J  = mean( abs(J),  'all' );

std_E  = std( Es, 0, 'all' );
std_A  = std( As, 0, 'all' );
std_rho= std(rho, 0, 'all' );
std_J  = std(  J, 0, 'all' );
%length and time scales
L = grid{1}(end) - grid{1}(1); %Use size of domain
T = grid{3}(end) - grid{3}(1); %Use size of domain




a = 1; %running index over library space

x = 1:nw;
y = nw + b;

labels{a} = "E_i";
G(x,a)    = SPIDER_integrate( Es(:,:,:,1), [], grid, corners, size_vec, pol );
G(y,a)    = SPIDER_integrate( Es(:,:,:,2), [], grid, corners, size_vec, pol );
scales(a) = mean_E;
a         = a+1;

labels{a} = "A_i";
G(x,a)    = SPIDER_integrate( As(:,:,:,1), [], grid, corners, size_vec, pol );
G(y,a)    = SPIDER_integrate( As(:,:,:,2), [], grid, corners, size_vec, pol );
scales(a) = mean_A;
a         = a+1;

labels{a} = "\partial_t A_i";
G(x,a)    = SPIDER_integrate( As(:,:,:,1), [3], grid, corners, size_vec, pol );
G(y,a)    = SPIDER_integrate( As(:,:,:,2), [3], grid, corners, size_vec, pol );
scales(a) = std_A/T;
a         = a+1;




%normalize
norm_vec = SPIDER_integrate( 0*rho + 1, [], grid, corners, size_vec, pol );      
norm_vec = repmat( norm_vec, [dof,1] );

G = G./norm_vec;
G = G./scales;

